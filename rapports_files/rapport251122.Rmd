---
title: "Rapport de la semaine du 22 au 29 Novembre 2022"
author: "SAMA Fousseni"
date: "`r Sys.Date()`"
output: word_document
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
```

# Compte rendu de la rencontre du 22 Novembre 2022
Lors de la rencontre du 22 Novembre dernier, plusieurs points concernant le processus de simulation des données ScHic ont fait l'objet de discussion. 
D'abord un point a été fait sur les données envoyées par Fousseni sur les lients entre les billes d'un meme cluster lors de la simulation des données. En effet, afin de comprendre le deroulement de la simulation des données, des données sur la connection des billes a été générées. Après analyse, il en resortait que quelques billes d'un meme cluster, pouvaient être connectées dans les deux sens (A->B et A<-B), ce qui justifie le fait d'avoir plus d'un contact dans une matrice scHic d'une seule structure. S'agit-il d'une erreur que les auteurs n'ont pas pu voir ? ou les auteurs ont ils vu cette eurreur mais ont decidé de l'ignorer comte tenu de leur faible nombre ? ou un detail nous a t il achappé ? Telles sont les interrogations soulevées lors de notre dernière rencontre concernant ces contacts. Afin de procéder a quelques verification, il a été demandé à Fousseni de générer des matrices de contacts scHic en retenant tous les contacts possibles, afin de comparer les contacts trouvés dans ces dernières aux contacts de la matrice d'incidence.
Par la suite, s'en ai suivi quelques échanges aucours desquelles nous avons fini par conclure que la différence que nous observons entre la simulation des données scHic (Expérimentalement) et la matrice d'incidence ("La vérité sur les vrais contacts") est bien normal. En effet, en comparant le code de construction des clusters dans la fonction CROSSLINKING avec la fonction fill_cluster du Hic et celui de la construction de clusters du GAM (la fonction perform_NP_cut avec add_to_cluster), nous avons pu constater qu'avec la méthode GAM, la fonction fill_cluster n'état pas utilisée.
Pour avancer dans le traitemant de données, il a été decidé de générer les données scHic avec les 250 cellules du code original de Fiorillo et al avec 4 billes par bac afin que les CRHs soient valides biologiquement puis par la suite, traiter ces données avec HiCImpute (Xie, Han, Jin et Lin, 2021).

# Vérification 
Cette partie permet de verifier que pour une structure données, le nombre de contacts trouvés dans la matrice scHic avec toutes les contraintes levées est presque égale au nombre de contacts de la matrice d'incidence.

Dans la matrice :
inc_mat_1 : le nombre de contacts trouvés dans la matrice d'incidence de la structure 1, 
hic_mat_1 : le nombre de contacts trouvés dans la matrice scHic de la structure 1, 
perc_1 : le pourcentage de contacts couvert par la matrice scHic pour la structure 1, 

inc_mat_2 : le nombre de contacts trouvés dans la matrice d'incidence de la structure 2, 
hic_mat_2 : le nombre de contacts trouvés dans la matrice scHic de la structure 2, 
perc_2 : le pourcentage de contacts couvert par la matrice scHic pour la structure 2.

```{r message=FALSE, warning=FALSE}
sum_matrix_incidence <- matrix(
  0, 
  nrow = 10, 
  ncol = 6, 
  byrow = TRUE,
  dimnames = list(
    paste0("cell ",1:10), 
    c("inc_mat_1", "hic_mat_1", "perc_1", "inc_mat_2", "hic_mat_2", "perc_2")
  )
)

nb_replicas = 10

for (r in 1:nb_replicas) {
  
  # Construction de la matrice d'incidence avec la première structure de la cellule
  for (p in 1:2) {
    data = read.table(
      paste0("rdata/cell_folder/cell_", sprintf("%03d", r), "/paire_", p,".txt"), 
      quote="\"", 
      comment.char="", 
      stringsAsFactors = FALSE
    )
    
    data$ID <- paste0("B", sprintf("%02d", data$V4), sprintf("%04d", 1:nrow(data)))
    
    # data = data[data$V4 != 1, ]
    
    three_dim_data <- data[, 1:3]
    mat_row_name = data$ID
    
    compute_dist <- as.matrix(
      dist(
        x = three_dim_data, 
        method = "euclidean", 
        diag = TRUE
      )
    )
    
    compute_dist_bin1 <- sapply(
      compute_dist, 
      FUN = function(item) ifelse(item<3, 1, 0)
    )
    
    compute_dist_bin1 <- matrix(
      compute_dist_bin1, 
      nrow = nrow(compute_dist), 
      ncol = ncol(compute_dist), 
      byrow = TRUE,
      dimnames = list(mat_row_name, mat_row_name)
    )
    
    diag(compute_dist_bin1) <- 0
    
    # compute_dist_bin1 est la première matrice d'incidence. Il faut mettre à présent à 0 toutes les interaction entre les billes de différentes couleures de la matrice. Il nous suffit donc de verifier si les billes en ligne et en colonne sont du meme bloc
    for (l in mat_row_name) {
      for (c in mat_row_name) {
        if (str_sub(l, 1, 3) != str_sub(c, 1, 3)|str_sub(l, 1, 3) == "B01"|str_sub(c, 1, 3) == "B01"){
          compute_dist_bin1[l, c] = 0
        }
      }
    }
    
    scData <- read.table(
          paste0("Sc_Cell_In-silico_Hi-C/simulation_with_single_structures/hic_mat_", sprintf("%03d", r), "_", p,".txt"), 
          quote="\"", 
          comment.char="", 
          stringsAsFactors = FALSE
        )
    
    if(p==1){
      sum_matrix_incidence[r, 1] <- sum(compute_dist_bin1)
      sum_matrix_incidence[r, 2] <- sum(scData)
      sum_matrix_incidence[r, 3] <- ((sum_matrix_incidence[r, 1]*2)/sum_matrix_incidence[r, 2])*100
    }else{
      sum_matrix_incidence[r, 4] <- sum(compute_dist_bin1)
      sum_matrix_incidence[r, 5] <- sum(scData)
      sum_matrix_incidence[r, 6] <- ((sum_matrix_incidence[r, 4]*2)/sum_matrix_incidence[r, 5])*100
    }
  }
  
}

sum_matrix_incidence

```


# Création d'une fonction permettant de générer des données sur les contacts par bac (La vérité sur les vrais contacts entre bacs)

```{r message=FALSE, warning=FALSE}
# La fonction incidence_matrice_fn permet de générer la matrice de conatcts entre les bacs d'une structure
incidence_matrice_fn <- function(structure, beads_to_bins){
  beads_number = nrow(structure)
  bins_number = beads_number%/%beads_to_bins
  
  matrix_incidence <- matrix(
    0, 
    nrow = bins_number, 
    ncol = bins_number, 
    byrow = TRUE
  )
  structure$ID <- paste0("B", sprintf("%02d", structure$V4), sprintf("%04d", 1:beads_number))
  
  if(beads_number%%beads_to_bins==0){
    
    for (bins_i in seq(bins_number)) {
      start_i = bins_i*beads_to_bins - beads_to_bins + 1
      end_i = bins_i*beads_to_bins
      
      for (bins_j in seq(bins_number)) {
        start_j = bins_j*beads_to_bins - beads_to_bins + 1
        end_j = bins_j*beads_to_bins
        
        if(bins_i == bins_j){
          matrix_incidence[bins_i, bins_j] = 0
        }else{
          data_in_bins = bind_rows(
            structure[start_i:end_i, ], 
            structure[start_j:end_j, ]
          )
          
          three_dim_data <- data_in_bins[, 1:3]
          mat_row_name = data_in_bins$ID
          
          compute_dist <- as.matrix(
            dist(
              x = three_dim_data, 
              method = "euclidean", 
              diag = TRUE
            )
          )
          
          compute_dist_bin <- sapply(
            compute_dist, 
            FUN = function(item) ifelse(item<3, 1, 0)
          )
          
          compute_dist_bin <- matrix(
            compute_dist_bin, 
            nrow = nrow(compute_dist), 
            ncol = ncol(compute_dist), 
            byrow = TRUE,
            dimnames = list(mat_row_name, mat_row_name)
          )
          
          diag(compute_dist_bin) <- 0
          # On retire les contacts entre les billes d'un meme bac
          compute_dist_bin[1:beads_to_bins, 1:beads_to_bins] <- 0
          bac2_i = beads_to_bins + 1
          bac2_j = beads_to_bins*2
          compute_dist_bin[bac2_i:bac2_j, bac2_i:bac2_j] <- 0
          
          for (l in mat_row_name) {
            for (c in mat_row_name) {
              # On retire les contacts entre les billes du premiers block puisqu'elles sont inertes
              if(str_sub(l, 1, 3) == "B01"|str_sub(c, 1, 3) == "B01"){
                compute_dist_bin[l, c] <- 0
              }
              # On retire les contacts des billes qui ne sont pas dans le meme block
              if (str_sub(l, 1, 3) != str_sub(c, 1, 3)){
                compute_dist_bin[l, c] <- 0
              }
            }
          }
          matrix_incidence[bins_i, bins_j] <- sum(compute_dist_bin)
          matrix_incidence[bins_j, bins_i] <- sum(compute_dist_bin)
        }
      }
      
    }
    return(matrix_incidence)
  }else{
    print("le nombre de bacs n'est pas divisible avec le nombre de billes !")
  }
}


ncells = 5
# Faire un update de matrice d'incidence pour deux structures afin d'obtenir une matrice pour chaque cellule
for (cell in seq(ncells)) {
  
  mat1 <- incidence_matrice_fn(
        read.table(
          paste0("rdata/cell_folder/cell_", sprintf("%03d", cell), "/paire_1.txt"), 
          quote="\"", 
          comment.char="", 
          stringsAsFactors = FALSE
        ),
        4
      )
  mat2 <- incidence_matrice_fn(
        read.table(
          paste0("rdata/cell_folder/cell_", sprintf("%03d", cell), "/paire_2.txt"), 
          quote="\"", 
          comment.char="", 
          stringsAsFactors = FALSE
        ),
        4
      )
  mat_len = dim(mat1)[1]
  mat <- matrix(
    0, 
    nrow = mat_len, 
    ncol = mat_len, 
    byrow = TRUE
  )
  for (i in seq_len(mat_len)) {
    for (j in seq_len(mat_len)) {
     mat[i, j] = mat1[i, j] + mat2[i, j]
    }
  }
  rm("mat1", "mat2")
}

# Comparaison des contacts trouvés par le scHic et la fonction incidence_matrice_fn de la première cellule
for (i in 1:5) {
  data <- read.table(paste0("Sc_Cell_In-silico_Hi-C/scenario0/hic_mat_", sprintf("%03d", i), ".txt"), quote="\"", comment.char="", stringsAsFactors = FALSE)
  print(max(data))
  print((sum(data)/sum(mat))*100)
  print(dim(data))
}

```


# Traitement des données avec HiCImpute

HiCImpute prend trois formats de données :
- Le premier, qui est le format préféré est une matrice avec des données sur le scHic, où chaque colonne est un vecteur de la matrice triangulaire supérieure sans inclure les entrées diagonales de la matrice 2D d'une cellule unique puisque la matrice est symétrique. Ce qui correspond à (n*n - n)/2 ligne pour une cellule données.
- Le deuxième est une liste de matrice brute scHic de chaque cellule. Nous choisissons ce format, car il nous évite de faire des traitement supplémentaires sur les données.
- Le troisième format est celui ou les données sur les cellules sont disposées en vrac.


```{r}
# Chargement du package
library("devtools")
# Install "HiCImpute" package from github.
# install_github("https://github.com/sl-lin/HiCImpute")
library(HiCImpute)
```


```{r}
# Disposition des données dans une liste
ncol = 562
ncells = 50
data_dim = ncol*(ncol-1)/2

hicImpute_data <- matrix(
  0, 
  nrow = data_dim, 
  ncol = ncells, 
  byrow = TRUE
)

for (i in seq_len(ncells)) {
  mat <- as.matrix(
    read.table(
      paste0("Sc_Cell_In-silico_Hi-C/scenario0/hic_mat_", sprintf("%03d", i), ".txt"), 
      quote="\"", 
      comment.char="", 
      stringsAsFactors = FALSE
    ) 
  )
  
  hicImpute_data[, i] <- mat[upper.tri(mat)]
}
rm("mat")
colnames(hicImpute_data) <- str_c("cell_", seq_len(ncells))

# Nous prenons ici les paramètres par défaut de la fonction MCMCImpute. Cepandant comme nous ne disposons pas de données en vrac, nous mettons bulk à NULL. Nous pouvons cependant aussi générer les données en vrac à partir du code du simulation de départ en prennant en compte toutes les cellules comme le faisait les auteurs.
set.seed(1234)
scHiC_Kmeans()

data("GSE117874_chr1_wo_diag")
data("GSE117874_imp")
cluster=scHiC_Kmeans(
  hicImpute_data, 
  centers=15, 
  nstart=1, 
  iter.max=1000, 
  seed=1
)
```


